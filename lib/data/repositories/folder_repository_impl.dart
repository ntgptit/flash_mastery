import 'package:dartz/dartz.dart';
import 'package:flash_mastery/core/constants/config/app_constants.dart';
import 'package:flash_mastery/core/constants/validation/error_messages.dart';
import 'package:flash_mastery/core/exceptions/exceptions.dart';
import 'package:flash_mastery/core/exceptions/failures.dart';
import 'package:flash_mastery/data/datasources/folder_local_data_source.dart';
import 'package:flash_mastery/data/models/folder_model.dart';
import 'package:flash_mastery/domain/entities/folder.dart';
import 'package:flash_mastery/domain/repositories/folder_repository.dart';

class FolderRepositoryImpl implements FolderRepository {
  final FolderLocalDataSource localDataSource;

  FolderRepositoryImpl({required this.localDataSource});

  @override
  Future<Either<Failure, List<Folder>>> getFolders() async {
    try {
      final folders = await localDataSource.getFolders();
      return Right(folders.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Folder>> getFolderById(String id) async {
    try {
      final folder = await localDataSource.getFolderById(id);
      return Right(folder.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Folder>> createFolder({
    required String name,
    String? description,
    String? color,
  }) async {
    try {
      final trimmedName = name.trim();
      final trimmedDescription = description?.trim();
      if (trimmedName.isEmpty) {
        return Left(ValidationFailure(message: ErrorMessages.fieldRequired));
      }

      if (trimmedName.length < AppConstants.minFolderNameLength) {
        return Left(
          ValidationFailure(message: ErrorMessages.textTooShort(AppConstants.minFolderNameLength)),
        );
      }

      if (trimmedName.length > AppConstants.maxFolderNameLength) {
        return Left(
          ValidationFailure(message: ErrorMessages.textTooLong(AppConstants.maxFolderNameLength)),
        );
      }

      if (trimmedDescription != null &&
          trimmedDescription.length > AppConstants.maxFolderDescriptionLength) {
        return Left(
          ValidationFailure(
            message: ErrorMessages.textTooLong(AppConstants.maxFolderDescriptionLength),
          ),
        );
      }

      final folderModel = FolderModel(
        id: '', // Will be generated by data source
        name: trimmedName,
        description: trimmedDescription,
        color: color,
        deckCount: 0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final createdFolder = await localDataSource.createFolder(folderModel);
      return Right(createdFolder.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Folder>> updateFolder({
    required String id,
    String? name,
    String? description,
    String? color,
  }) async {
    try {
      final existingFolder = await localDataSource.getFolderById(id);
      final trimmedName = name?.trim();
      final trimmedDescription = description?.trim();

      if (trimmedName != null && trimmedName.isEmpty) {
        return Left(ValidationFailure(message: ErrorMessages.fieldRequired));
      }

      if (trimmedName != null && trimmedName.length < AppConstants.minFolderNameLength) {
        return Left(
          ValidationFailure(message: ErrorMessages.textTooShort(AppConstants.minFolderNameLength)),
        );
      }

      if (trimmedName != null && trimmedName.length > AppConstants.maxFolderNameLength) {
        return Left(
          ValidationFailure(message: ErrorMessages.textTooLong(AppConstants.maxFolderNameLength)),
        );
      }

      if (trimmedDescription != null &&
          trimmedDescription.length > AppConstants.maxFolderDescriptionLength) {
        return Left(
          ValidationFailure(
            message: ErrorMessages.textTooLong(AppConstants.maxFolderDescriptionLength),
          ),
        );
      }

      final updatedFolder = existingFolder.copyWith(
        name: trimmedName ?? existingFolder.name,
        description: trimmedDescription ?? existingFolder.description,
        color: color ?? existingFolder.color,
      );

      final result = await localDataSource.updateFolder(updatedFolder);
      return Right(result.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteFolder(String id) async {
    try {
      await localDataSource.deleteFolder(id);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<Folder>>> searchFolders(String query) async {
    try {
      final folders = await localDataSource.searchFolders(query);
      return Right(folders.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}
