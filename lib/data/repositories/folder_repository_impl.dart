import 'package:dartz/dartz.dart';
import '../../core/exceptions/exceptions.dart';
import '../../core/exceptions/failures.dart';
import '../../domain/entities/folder.dart';
import '../../domain/repositories/folder_repository.dart';
import '../datasources/folder_local_data_source.dart';
import '../models/folder_model.dart';

class FolderRepositoryImpl implements FolderRepository {
  final FolderLocalDataSource localDataSource;

  FolderRepositoryImpl({required this.localDataSource});

  @override
  Future<Either<Failure, List<Folder>>> getFolders() async {
    try {
      final folders = await localDataSource.getFolders();
      return Right(folders.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Folder>> getFolderById(String id) async {
    try {
      final folder = await localDataSource.getFolderById(id);
      return Right(folder.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Folder>> createFolder({
    required String name,
    String? description,
    String? color,
  }) async {
    try {
      final folderModel = FolderModel(
        id: '', // Will be generated by data source
        name: name,
        description: description,
        color: color,
        deckCount: 0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final createdFolder = await localDataSource.createFolder(folderModel);
      return Right(createdFolder.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Folder>> updateFolder({
    required String id,
    String? name,
    String? description,
    String? color,
  }) async {
    try {
      final existingFolder = await localDataSource.getFolderById(id);
      final updatedFolder = existingFolder.copyWith(
        name: name ?? existingFolder.name,
        description: description ?? existingFolder.description,
        color: color ?? existingFolder.color,
      );

      final result = await localDataSource.updateFolder(updatedFolder);
      return Right(result.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteFolder(String id) async {
    try {
      await localDataSource.deleteFolder(id);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<Folder>>> searchFolders(String query) async {
    try {
      final folders = await localDataSource.searchFolders(query);
      return Right(folders.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on CacheException catch (e) {
      return Left(CacheFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}
